<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <script src="scripts/d3.v4.0.0-rc.2.min.js"></script>
  <script src="scripts/topojson.v1.min.js"></script>
  <script src="scripts/d3-geo-projection.v1.min.js"></script>

  <title>Document</title>
  <style>
  @import url('https://fonts.googleapis.com/css?family=Oswald:300,400');
  body {
    margin:0;
    width:100%;
    height:100%;
    background-color: #62eaee;
    font-family: 'Oswald', sans-serif;
    font-weight:300;
  }
  path.country {
    stroke-linejoin:round;
    stroke-width:.5;
    /*stroke:none;*/
  }
  text {
    font-size:.3em;
  }
  circle {
    fill:none;
    stroke:black;
    stroke-width:.5;
  }
  #main-map {
    position: absolute;
    left:0;
    top:0;
    overflow:visible;
    padding-bottom:40%;
    width:100%;
    height:100%;
  }
  /*.country:hover {
    stroke:red;
    stroke-width:1;
    transition: 0.2s;
  }*/
  .wrapper {
    position: relative;
    width:100vw;
    height:100vh;
    overflow:hidden;
  }
  .text {
    z-index:100;
  }
  .flow-line {
    stroke-opacity:0.5;
    stroke-width:.8;
    stroke-linecap:round;
  }
  .flowtype-export {
    stroke:blue;
  }
  .flowtype-import {
    stroke:url('#flowGrad');
  }
  </style>
</head>
<body>
  <div class="wrapper">
    <svg id="main-map" viewBox="0 0 960 600" preserveAspectRatio="xMidYMin meet">
      <defs>
        <linearGradient id="flowGrad">
            <stop offset="5%"  stop-color="yellow"/>
            <stop offset="95%" stop-color="blue"/>
        </linearGradient>
    </defs>
    </svg>
  </div>

</body>
<script>
  "use strict";
  d3.json("world.json",function(error, world) {
    if (error) return console.error(error);

    //set up variables
    var countrydata = topojson.feature(world, world.objects.countries).features;
    var map = d3.select("#main-map");
    //defining projection: Mercator, Equirectangular, AzimuthalEqualArea, ConicConformal
    var projection = d3.geoMercator()
      .clipExtent(null)
      .center([0, 30.4]);
    var path = d3.geoPath()
      .projection(projection);

    //set up color scale for gdp
    var gdpMin = d3.min(countrydata, function(d) {return +d.properties.gdp}),
    gdpMax = d3.max(countrydata, function(d) {return +d.properties.gdp}),
    gdpHalf = (gdpMin + gdpMax) / 2,
    gdpFirstQ = (gdpMin + gdpHalf) / 2,
    gdpSecondQ = (gdpMax + gdpHalf) / 2;

    //set domain and range for gdp color scale
    var gdpScale = d3.scaleLog()
      .domain([761, 18036648])
      .range(["#5cb1f7","#eb384e"]);

    //balanceScale: d3.extent(countrydata, function(d) {return +d.properties.balance})
    var balanceScale = d3.scaleLinear()
      .domain([-469400, 0 ,301400])
      .range(['#ff5d5d','#7680de','#3941ff']);

    //add country topography
    var countries = map.append("g").attr("class","countries").selectAll("path")
      .data(countrydata)
      .enter().append("path")
        .attr("d", path)
        .attr("class", function(d){ return "country " +  d.id})
        .attr("fill", function(d){
            // return (d.properties.balance == null) ?  "#c3c3c3" : balanceScale(+d.properties.balance)
            return (d.properties.gdp == null) ?  "#c3c3c3" : gdpScale(+d.properties.gdp)
        })
        .attr("stroke",function(d){
          return (d.properties.eu == true) ? "blue" : "white"
        });

    //import trade flow data
    d3.csv('tradeflow.csv',function row(d) {
      return {
        reporter: d.reporterIso,
        partner: d.partnerIso,
        flowValue: +d.value,
        flowType: +d.flowBinary,
        flowRank: +d.flowRank
      }
      },
      function(error, flow) {

        //function that returns matching topography groups when passed a country code
        function filterCountry(key) {
          var rep = countrydata.filter(function(d) {
            if (d.id == key.reporter) {
              return d;
            }
          });
          var part = countrydata.filter(function(d) {
            if (d.id == key.partner) {
              return d;
            }
          });
          return [rep, part];
        };

        //create svg group to append flow lines into
        var flowLayer = map.append("g").attr("class","flow");

        //draw trade lines
        flowLayer.append("g")
        .selectAll(".flow")
            .data(flow)
        .enter()
        .filter(function(d){
          if (+d.flowRank == 1) { return d}
        })
          .append("path")
            .attr("d",function(d) {
              let country = filterCountry(d),
              x1 = path.centroid(country[0][0])[0],
              y1 = path.centroid(country[0][0])[1],
              x2 = path.centroid(country[1][0])[0],
              y2 = path.centroid(country[1][0])[1],
              text = "M"+x1+","+y1+" L "+x2+","+y2+" Z";
              return text;
            })
            .attr("class",function(d) {
              // console.log(+d.flowBinary);
              let flowType;
              (+d.flowType == 0) ? flowType = "export" : flowType = "import";
              return "flow-line flowtype-" + flowType;
            })
            .style("opacity","0")
          .transition().style("opacity","1").duration(100);

        //add svg group for text and append country name labels
        map.append("g").attr("id","text")
          .selectAll("g")
            .data(countrydata)
          .enter()
              .append("g")
                .append("text")
                  .text(function(d) {return d.properties.name})
                  .attr("transform",function(d) {return "translate(" + path.centroid(d) + ")"})
                  .attr("dx","1px")
                  .attr("dy","2px");

        //draw point cicles next to country name labels
        map.select("g#text")
          .selectAll("g")
            .data(countrydata)
            .filter(function(d){
              if(typeof d.properties.name != 'undefined') {return d}
            })
            .append("circle")
              .attr("r",".5")
              .attr("transform",function(d){return "translate(" + path.centroid(d) + ')'});




        }
      )
  })
</script>
</html>
